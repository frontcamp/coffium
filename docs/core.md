
Coffium::CORE
=============


Назначение и границы ядра
-------------------------


### Состав ядра

- `/libs` - библиотеки ядра
- `.htaccess` - перенаправление запросов на index.php
- `cfg.*.php` - файлы конфигурации системы, окружения и проекта
- `index.php` - точка входа в обработку запроса


### Задачи ядра (жизненный цикл запроса)

1) перенаправление всех запросов на `index.php` `(.htaccess)`
2) инициализация системы `(cfg.*.php)`
3) организация системного реестра `($SYS, /libs/inc.registry.php)`
4) автозапуск `(/coms/__init__.php)`
5) анализ запроса `(/libs/inc.request.php)`
6) маршрутизация: реализация зависимостей, инициализация компонентов и запуск обработчиков `(/libs/inc.response.php)`
7) экстренная остановка маршрутизации
8) финализация


### Чего ядро НЕ делает

Ядро Coffium минималистично. Предполагается, что вся дополнительная функциональность реализуется исключительно через компоненты. Таким образом:

- ядро не кеширует
- ядро не блокирует
- ядро не работает с БД
- ядро не шаблонизирует
- ядро не имеет хуков (кроме финализаторов)
- ядро не имеет административного интерфейса
- не печет тортики и не вышивает крестиком


Перенаправление запросов
------------------------

С помощью .htaccess все запросы перенаправляются на `index.php`

Исключения:
- `favicon.ico`
- `robots.txt`
- `/web` каталоги в дереве компонентов `/coms`

При необходимости список исключений может быть расширен.


Инициализация системы
---------------------


### cfg.global.php

Глобальная конфигурация определяет параметры ядра, системы, PHP и спец. доступа.


#### ML_URL_SUPPORT = <True|False>

Поддержка URL-мультиязычности.

`True` - маршрутизатор отбрасывает первый сегмент URL-пути при построении `route.path`. Например, при запросе:

`https://<server>/de/home/`

сегмент `de` игнорируется, а маршрутизатор ищет обработчик страницы в корне компонента: `/coms/home`

Этот флаг обеспечивает работу механизма URL-мультиязычности. Подразумевается, что первый (игнорируемый) сегмент используется компонентом мультиязычности (например, `mlang`) для определения текущего языка и подключения соответствующего словаря с переводами.

`False` - обычная маршрутизация, при которой первый сегмент учитывается. Следует использовать в одноязычных проектах или, при использовании другого механизма мультиязычности, например, управление языками через GET/POST параметры.


#### ML_DIR_SUPPORT = <True|False>

`True` - подключение языковых файлов (словарей) из каталогов `/_lang` от корня компонентов до каталога обработчика.

Например, для обработчика `/coms/help/contents/` будут подключены все PHP файлы из следующих каталогов (включая вложенные папки, если они есть в каталогах `/_lang`):
```
/coms/_lang
/coms/help/_lang
/coms/help/contents/_lang
```

Это сделано, чтобы можно было располагать словари с переводами по месту их использования и, при необходимости, структурировать тематически.

Предполагается, что подключаемые файлы содержат массив с именем `$DICTIONARY`. Формат массивов (словарей) должен быть согласован с компонентом мультиязычности (например, `mlang`).

`False` - если используется кастомный механизм реализации мультиязычности, например, суперсловари (глобальные словари в корне проекта или в корне каждого компонента).

**ПОДСКАЗКА:** компонент с переводами может работать без компонента мультиязычности, с помощью API-заглушки:

```php
if (!function_exists('ml')) {
    function ml($text) { return $text; }
}
```

При этом сообщения выводятся как есть.


#### Тип сервера (IS_CRON|IS_LOCAL|IS_DEV|IS_PROD)

С помощью флагов `IS_CRON|IS_LOCAL|IS_DEV|IS_PROD` можно определять сервер-зависимую логику. Флаги устанавливаются автоматически.

**ВАЖНО:** поскольку в каждой организации dev-сервер реализуется по-своему (локально, на внешнем сервере, на субдомене, в другой доменной зоне и т.д.), следует уточнить признаки флага `IS_DEV`.

SERVER_TYPE = Local|Development|Production + суффикс -Cron для CLI/cron.


#### Системные пути и URL-адреса

`TIME_HASH` - динамический хеш на базе текущего времени и типа сервера.

По умолчанию, для `LOCAL` & `DEV` сервера обновляется каждую секунду, а для `PROD` сервера раз каждый час (можно увеличить до суток или месяца).
Это значение удобно использовать в качестве `GET` параметра для принудительной перезагрузки статики в браузере (стилей, скриптов и картинок). Например:

```php
<link href="https://<server>/home/web/s/default.css?v=<?=TIME_HASH?>" rel="stylesheet" type="text/css">
```

`PROJ_ROOT` - абсолютный путь к корню системы/проекта, определяется как каталог, в котором находится данный файл конфигурации. Это позволяет располагать систему не только в корне сервера, но и в подкаталогах.

`COMS_PATH|COMS_ROOT` - корневой каталог компонентов
`LOGS_PATH|LOGS_ROOT` - корневой каталог лог-файлов
`TEMP_PATH|TEMP_ROOT` - корневой каталог временных файлов


#### Конфигурация PHP

Этот раздел глобальной конфигурации включает в себя PHP настройки времени, безопасности, компрессии, сессии, логирования и кодировки. Описание соответствующих функций, параметров и значений можно найти в документации PHP.


#### VIP доступ

VIP режим целесообразно использовать для получения доступа к инструментам отладки и разработки, а также для временного скрытия от клиентов частей проекта, находящихся в разработке.

`VIP_MODE_KEY` - определяет `GET/POST` ключ, с помощью которого можно управлять VIP доступом

**ВАЖНО:** значение ключа `VIP_MODE_KEY` следует обязательно изменить!

Для активации VIP доступа нужно к любому URL проекта добавить GET параметр с заданным ключом и значением `<1|on|yes|true>`. Например, если ключ указан как `projkeeper`, то URL будет:

```https://<server>/home/?projkeeper=on```

Это установит в сессии флаг `$_SESSION['core.vip_access']`, и режим VIP доступа будет работать до отключения, или пока не будет сброшена сессия. Выключить этот режим можно таким же способом, указав любое другое значение, например:

```https://<server>/home/?projkeeper=off```

Для удобства работы создается константа `IS_VIP`, с помощью которой в любом месте проекта можно проверить состояние данного режима доступа.
Пример использования VIP доступа:

```php
if (!IS_VIP) redirect('/home/');
```


### cfg.server.php

Определяет сервер-зависимую конфигурацию: учетные данные к БД и другие параметры, которые различаются между окружениями `LOCAL`, `DEV`, `PROD` и задачами `CRON`.


### cfg.custom.php

Содержит настройки, специфичные для проекта. Используется для централизованного управления конфигурацией без правок отдельных конфигов внутри компонентов.

**РЕКОМЕНДАЦИЯ:** компоненты дублируют параметры с проверкой на предварительное определение, например:

```php
if (!defined('APP_FEATURE_X_ENABLED')) {
    define('APP_FEATURE_X_ENABLED', 'default_value');
}
```

Это позволяет безопасно комментировать или удалять значения в `cfg.custom.php`: при отсутствии константы компонент подставит значение по умолчанию.


Системный реестр
----------------

Системный реестр реализован как глобальный массив $SYS и набор функций для работы с ним. API реестра описан в файле: `/libs/inc.registry.php`.

Соглашение по именованию ключей реестра:

```компонент.параметр```

или

```компонент.подсистема.параметр```

Исключение: ядро системы добавляет ключи без префикса.

**ВАЖНО:** доступ к реестру должен выполняться только через API-функции. В следующих версиях ядра глобальная переменная `$SYS` может быть скрыта из глобальной области видимости ради безопасности и стабильности.

Ядро создает в реестре и наполняет данными несколько ключей с отладочной информацией:
- `included` - массив путей ко всем подключенным файлам системы
- `runtime` - метка времени начала обработки
- `route.stack` - отладочный стек маршрутизации
- `lng.loaded` - список загруженных словарей
- `ini.loaded` - список загруженных инициализационных файлов
- `inf.loaded` - список загруженных информационных файлов
- `api.loaded` - список загруженных API
- `hdl.loaded` - список подключенных обработчиков

Эти данные позволяют отслеживать логику работы ядра в нужные моменты времени.


Анализ запроса
--------------

Исходный код библиотеки: `/libs/inc.request.php`
Задача - анализ данных запроса и сохранение в системном реестре (ключи `request` и `route.*`).

Сохраняются следующие значения:

- `request.scheme` = `<http|https>`
- `request.port` = `<порт>`
- `request.host` = `<имя сервера>`
- `request.uri` = `<URL-путь ? GET-параметры>`
- `request.query_raw` = `<?get_query>`
- `request.query_str` = `<get_query>`
- `request.root` = `<scheme://root:port>` (порт указывается только если отличается от 80 или 443)
- `request.path` = `<URL-путь>`
- `request.orig` = `<URL-адрес>`
- `request.base` = `<базовый URL-адрес>` (без GET параметров)

- `route.path_raw` = `<валидированный request.path>`
- `route.path` = `<route.path_raw>` (начальное значение)
- `route.chunks_raw` = `<сегменты route.path>`
- `route.chunks` = `<route.chunks_raw>` (начальное значение)

Параметры `route.path` и `route.chunks` изменяются в процессе маршрутизации. Первоначальные значения хранятся в ключах `route.path_raw` и `route.chunks_raw`.

**ВАЖНО:** в пути к обработчику не допускаются точки и двойные разделители, после них всё игнорируется.

**ВАЖНО:** определение режима AJAX происходит по наличию в GET/POST-запросе ключа `ajax`. Если в проекте используется другой протокол, следует изменить данное поведение.


Компонент и обработчик
----------------------

Компонентом является структурный элемент системы, реализующий специфический функционал. Компоненты находятся в каталоге `/coms`.
Компоненты условно можно разделить на два типа:

*сервис* - компонент, выполняющий внутренние функции системы, либо предоставляющий API интерфейс, но не обрабатывающий внешние URL-запросы (например: мультиязычность, кеш, статистика)

*модуль* - компонент, обрабатывающий внешние URL-запросы (например: admin, pages, blog, forum)

С точки зрения системы сервисы и модули не отличаются и работают в единой компонентной модели. Разделение на типы нужно только для удобства описания компонентов в документации.

Структура компонента:

```
/<component>/
    /_admin - административный интерфейс
    /_docs - документация
    /_lang - словари с переводами
    /_libs - собственные библиотеки
    __info__.php - информация о компоненте
    __init__.php - код инициализации
    api.main.php - API (основной)
    api.<name>.php - API (расширение)
    cfg.main.php - конфиг (основной)
    cfg.<name>.php - конфиг (расширение)
```

`api.<name>.php` - подключается вручную из основного API
`cfg.<name>.php` - подключается вручную из основного конфига

Файл: `__info__.php` обязателен для каждого компонента и имеет следующий формат:

```php
<?php
$CINF = array
(
    'title' => 'Administration',
    'descr' => 'Manage system configuration and components',
    'prefix' => 'ad_',
    'require' => array('common', 'mlang'),
    'version' => '0.1',
    'build' => '202407010141',
    'order' => PHP_INT_MAX,
);
```

где:
`title` - название компонента (для админ. интерфейса)
`descr` - краткое описание компонента (для админ. интерфейса)
`prefix` - уникальный префикс компонента (используется в конфигурации и API, для избежания коллизий с другими компонентами)
`require` - зависимости компонента в виде списка имен каталогов компонентов
`version` - текущая версия компонента
`build` - билд
`order` - порядок вывода компонента в админ. интерфейсе

Все ключи массива `$CINF` являются опциональными. Для ядра Coffium важно только поле `require`: через него реализуются зависимости компонентов (рекурсивные вызовы core_use_api() по именам каталогов компонентов). Остальные поля (`title`, `descr`, `prefix`, `version`, `build`, `order`) используются административным интерфейсом и вспомогательными инструментами - для отображения, сортировки и конфигурации, но не участвуют в работе маршрутизатора.

Наравне со служебными данными, описанными выше, компонент может содержать т.н. *обработчики*. **Обработчик**, как следует из названия, отвечает за обработку внешнего URL-запроса.

Для пояснения, обратимся к классической модели обработки URL-запроса, например, к серверу от клиента приходит URL-запрос вида:

```https://<server>/chunk1/chunk2/some.php```

сервер ищет в корне хоста каталог `/chunk1/chunk2` и в нем файл `some.php`. Если файл найден, он выполняется и результат возвращается клиенту, иначе возвращается сообщение об ошибке. Еще пример:

```https://<server>/chunk1/chunk2/```

сервер ищет в корне хоста каталог `/chunk1/chunk2` и в нем файл `index.html` или `index.php` (в зависимости от настроек). Если файл найден, он выполняется и результат возвращается клиенту, иначе возвращается сообщение об ошибке.

Похожим образом работает ядро Coffium, только каталог ищется не от корня хоста, а от корня компонентов `(/coms)` и вместо конкретного файла ищется *обработчик*. А в случае отсутствия каталога или обработчика, выполняется регрессия (поднятие вверх) в попытке найти наиболее вышележащий обработчик.

Под обработчиком `<name>` в системе Coffium понимается следующая совокупность каталогов и файлов:

```
/web/s/<name>.css - сопровождающие стили
/web/s/<name>.js  - сопровождающий джаваскрипт
act.<name>.php    - "экшн" файл с бизнес-логикой
tpl.<name>.php    - "шаблон" с версткой вывода
```

При обработке внешнего URL-запроса значение имеют только `act|tpl` файлы, `css|js` файлы не исполняются напрямую: при подключении обработчика их URL добавляются в системный реестр (ключи: `hdl.preload.css` и `hdl.preload.js`, соответственно), откуда их читает компонент разметки/шаблон при генерации тегов `<link>` и `<script>`.

По сути, `act.<name>.php` и `tpl.<name>.php` являются PHP-файлами, и подключаются одинаково. Это нужно для декомпозиции (четкого разделения) обработчика на бизнес-логику и шаблон вывода. Первым подключается бизнес-логика, вторым шаблон вывода. Между ними передается контекст (см. далее).

**ЗАМЕЧЕНИЕ:** В системе Coffium не используются сторонние шаблонизаторы, считается, что PHP сам по себе является мощным шаблонизатором и использовать что-то поверх него бессмысленно.

При поступлении внешнего URL-запроса вида:

```https://<server>/chunk1/chunk2/```

Система действует по следующему алгоритму:

1) ищется каталог `/chunk1/chunk2`, в нем ищется обработчик по умолчанию `(<act|tpl>.default.php)`, если один из этих файлов присутствует, обработчик считается найденным;

2) если обработчик по умолчанию не найден, ядро ищет каталог `/chunk1` и в нем ищет кастомный обработчик `(<act|tpl>.chunk2.php)`, если один из этих файлов присутствует, обработчик считается найденным;

3) если 1 и 2 шаги не дали результата, последний сегмент запроса убирается `(/chunk2)` и для полученного пути алгоритм поиска повторяется.

Как следствие, последней будет предпринята попытка подключить обработчик по умолчанию в корне каталога компонентов:

```/coms/<act|tpl>.default.php```

Следует это учитывать для обработки непредвиденных запросов. Примеры кода в файле `/coms/act.default.php`:

1) тихая подмена на главную страницу:

```php
<?php
core_use_handler('home');
```

2) редирект на главную страницу:

```php
<?php
redirect('/home');
```

3) выдача страницы с ошибкой:

```php
<?php
core_use_handler('static.error404');
```

4) или можно добавить код, который будет эмулировать вызов страниц из некоторой виртуальной структуры (например, в базе данных или во вложенной структуре каталогов).


Маршрутизация и реализация зависимостей
---------------------------------------

Механизм подключения компонентов с учетом их зависимостей реализуется функциями: `core_use_api()` и `core_use_handler()`. Эти функции являются самыми важными в работе системы Coffium, поэтому рассмотрим их детально.

Входной точкой маршрутизатора служит вызов
`core_use_handler(sys_get('route.path'))` в `index.php`: значение `route.path` формируется на этапе анализа запроса.

Обе функции используют функцию нормализации пути `_route_std_path()`, которая:
- конвертирует путь вида `comp.subdir.handler` в `/comp/subdir/handler`;
- отсекает всё, что идёт после сдвоенного слеша (`//`);
- гарантирует один ведущий слеш и отсутствие завершающего слеша (для пустого пути возвращается пустая строка).


### `core_use_api($target_path)`

Функция отвечает за инициализацию соответствующего компонента и подключение его API.

Эта функция поддерживает два варианта использования:

1) `$target_path` = имя каталога компонента

В этом случае из каталога компонента считывается INF файл, выполняется INI скрипт и подключается API.

2) `$target_path` = путь к обработчику (служебный вариант)

В этом случае выполняется всё то же, что в первом варианте, а затем выполняется спуск от корня компонента к каталогу обработчика с подключением языковых файлов из каталогов `/_lang` и инициализационных файлов `__init__.php` на каждом уровне пути. INF-файл и API по умолчанию читаются только на уровне корневого каталога компонента.

Второй вариант является служебным и используется ядром перед подключением обработчика. Вручную его использовать не следует.
Для ручного подключения API компонента используется первый вариант, например:

```php
core_use_api('mlang');
core_use_api('db');
```

Если в INF файле, в поле `require` указан массив с именами каталогов компонентов, перед инициализацией и подключением API происходит рекурсивный вызов core_use_api() для каждого из этих имен. Таким образом реализуются зависимости.


### `core_use_handler($path, &$CONTEXT, $flags)`

Функция подключает обработчик по указанному пути. `$CONTEXT` - это ассоциативный массив, который передаётся по ссылке во внутреннее замыкание, где выполняются `act.*.php` и `tpl.*.php`. Для него зарезервированы несколько специальных ключей:

- `CORE_EXTRACT_VARS (bool)` - если установлено в `true`, элементы `$CONTEXT` предварительно извлекаются в локальное пространство имён обработчика с помощью функции `extract()`. После этого ключ удаляется, чтобы переменная не «утекала» в шаблон.

- `CORE_ENABLE_BUFFER (bool)` - включает `ob_start()` на время работы обработчика. По умолчанию вывод act/tpl сразу отправляется в ответ.

- `CORE_RETURN_OUTPUT (bool)` - включает буфер и дополнительно заставляет `core_use_handler()` вернуть содержимое буфера как строку вместо прямой печати. Этот режим удобно использовать для компоновки виджетов и вложенных шаблонов.

По умолчанию все эти опции выключены.

Возвращаемое значение `core_use_handler()`:

`false` - обработчик (в рамках заданных флагов) не найден;

`true` - обработчик найден и отработал, но буфер не возвращался (вывод ушёл напрямую в поток ответа);

`string` - обработчик найден, был включён `CORE_RETURN_OUTPUT`, и функция вернула буферизированный вывод.

**ВАЖНО:** при проверке результата использовать строгое сравнение (`=== true` / `=== false`), чтобы не путать булевы значения и строку с контентом.

Флаги `($flags)` позволяют дополнительно управлять поведением функции. По умолчанию установлены флаги: `HDL_ALL|HDL_ASC_DEF|HDL_TRY_DEF`
`HDL_ALL` - подключать все типы файлов (`act`, `tpl`, `css`, `js`);
`HDL_ASC_DEF` - автоматически выполнять регрессию пути в поисках вышележащего обработчика вплоть до корня компонентов;
`HDL_TRY_DEF` - сначала интерпретировать путь как каталог и в нем искать обработчик по умолчанию, в случае неудачи интерпретировать последний сегмент пути как имя обработчика. Например, для запроса: `/chunk1/chunk2`:
1) проверяется наличие: `/chunk1/chunk2/<act|tpl.default.php>`;
2) при неудаче, наличие: `/chunk1/<act|tpl.chunk2.php>`;

Флаги определены в начале файла `/libs/inc.response.php`.

Поскольку `core_use_handler()` перед запуском обработчика вызывает для него же `core_use_api()`, это обеспечивает самоинициализацию компонента - подключение собственного API, реализацию зависимостей и иерархическую инициализацию и подключение языковых файлов.


Автозапуск
----------

Некоторые компоненты (сервисы) нужно запускать при каждом запросе, например: `blocker`, `cache`, `stats`. Так как они обеспечивают обязательные служебные функции системы.

Автозапуск реализуется ядром с помощью файла __init__.php в корневом каталоге компонентов (COMS_PATH/COMS_ROOT). Если файла нет, его нужно создать. Он выполняется перед началом основной маршрутизации. Пример кода:

```php
<?php
if (IS_PROD && !IS_CRON)  # production server only
{
    core_use_api('blocker');
    if (!IS_AJAX)
    {
        core_use_api('cache');
        core_use_api('stats');
    }
}
```

Этот код подключает соответствующие сервисы (подключает их API, в котором находится код, который должен быть выполнен). Дополнительного явного "запуска" не требуется.

**ЗАМЕЧЕНИЕ:** при подключении API компонента информация об этом сохраняется в системном реестре, это учитывается маршрутизатором и исключает дальнейшее повторное подключение API, даже если потом для этого же сервиса многократно вызывать core_use_api().

**ЗАМЕЧЕНИЕ:** рекомендуется использовать корневой __init__.php исключительно для автозапуска сервисов и избегать тяжеловесной логики.


Экстренная остановка маршрутизации
----------------------------------

Существует ряд ситуаций, в которых требуется внезапно прервать обработку запроса и совершить перенаправление на другую страницу. Например, обращение к странице без надлежащих прав доступа, блокировка злонамеренного запроса, нарушение в логике обработки (непоследовательное обращение к страницам опросника или мастера).

Это можно было бы решить вызовом функции редиректа, внутри которой есть предохраняющий die():

`redirect('URL')`

В этом случае не будут запущены финализаторы, а значит, кеш не будет корректно сброшен, запрос не будет учтен в статистике (если статистика реализована в виде финализатора), не закроются важные ресурсы (файловые указатели и соединение с БД).

Поэтому, именно для этого случая в Coffium предусмотрено исключение, которое прерывает инициализацию и/или маршрутизацию и ядро переходит к обработке финализаторов. При этом редирект исполняется в виде последнего финализатора.

Пример вызова исключения при проверке авторизации:

```php
if (!is_auth_user()) {
    core_terminate_and_redirect('/login');
}
```

В этом случае маршрутизация будет прервана, отработают финализаторы и перенеправление на указанный URL.

Пример вызова исключения для блокировки подозрительного запроса:

```php
if ($is_malicious_request) {
    core_terminate_route('Blocked malicious request');
}
```

В этом случае финализаторы отработают, но редиректа не будет.

Для возможности проверки финального статуса обработки запроса, в системный реестр добавляется ветка `response`, внутри которой создаются ключи:

1) при нормальном окончании запроса:

`status = CORE_STATUS_OK`

2) прерванная маршрутизация

```
status  = CORE_STATUS_TERMINATED
message = <redirection reason>

# при наличии редиректа:
redir_url  = <URL>
redir_code = <redirection code>
redir_by   = <redirection source>
```

Таким образом, можно проанализировать источник и причину прерывания и добавить эту информацию, например, в лог или статистику.


Финализация
-----------

После маршрутизации (когда завершен последний вызов `core_use_handler()`) точка входа `index.php` последовательно выполняет зарегистрированные финализаторы.

### Приоритеты финализаторов

Приоритеты задаются целочисленными константами, объявленными в `index.php`:

- `CORE_PRIO_LOW` — предварительная обработка данных перед основной финализацией (подготовка агрегатов, нормализация, очистка временных структур);
- `CORE_PRIO_NORMAL` — стандартные завершающие операции; значение по умолчанию;
- `CORE_PRIO_HIGH` — операции, зависящие от уже окончательно подготовленных данных (логирование, статистика, обновление кешей);
- `CORE_PRIO_HIGHEST` — выключение критичных ресурсов (соединения с БД, файловые дескрипторы, внешние клиенты).

Чем меньше числовое значение приоритета, тем раньше выполняется соответствующая группа финализаторов. Внутри одной группы функции вызываются в том порядке, в котором они были зарегистрированы.

### Регистрация финализаторов

Финализаторы регистрируются глобальной функцией:

```php
core_register_finalizer(callable $func, int $priority = CORE_PRIO_NORMAL);
```

Эту функцию можно вызывать из любого места проекта: API компонента, обработчика, вспомогательной библиотеки. В качестве `$func` допускаются именованные функции, статические методы, замыкания и другие допустимые `callable`. Например:

```php
<?php
# /coms/stats/api.main.php
core_register_finalizer(function () {
    stats_flush();
}, CORE_PRIO_HIGH);
```

Такой финализатор будет выполнен после основной логики обработчика, но до закрытия критичных ресурсов.

### Порядок выполнения и динамическая регистрация

Финализаторы выполняются группами, от группы с наименьшим приоритетом до группы с наибольшим приоритетом. Внутри групп финализаторы выполняются в порядке добавления. По мере выполнения, финализаторы удаляются из списка. Этот механизм позволяет регистрировать финализаторы динамически, даже из самих финализаторов.

В VIP-режиме перед запуском цикла сохраняется снимок всех зарегистрированных финализаторов `($_FINALIZERS_SNAPSHOT)`, который затем может быть выведен отладчиком как отдельный раздел `FINALIZERS` (см. файл `/libs/inc.helpers.php`).


Подключение и загрузка статики
------------------------------

Как описано выше, при подключении обработчика его файлы `/web/s/<name>.css` и `/web/s/<name>.js` (если существуют) не подключаются и не отдаются напрямую, а регистрируются в системном реестре под ключами `hdl.preload.css` и `hdl.preload.js`. Эти ключи представляют собой линейные стеки URL-адресов, которые затем использует layout/шаблон для генерации тегов `<link>` и `<script>`. Статические файлы привязаны к обработчику и автоматически находятся относительно его каталога по соглашению о структуре `/web/s`.
Этот механизм позволяет автоматически собирать по пути нахождения обработчика все сопутствующие CSS и JS файлы, что одновременно согласуется с принципом максимальной декомпозиции, автоматизирует рутину и при этом дает ручной контроль за финальным подключением в шаблон.

Дальнейшее касается именно порядка наполнения этих стеков и механизма *initial sub-stack*.

### Стек hdl.preload.<css|js>

Стек заполняется исключительно внутри `core_use_handler()` в момент подключения обработчиков:

- путь к статике вычисляется на базе `_route_mk_path()` и `core_static_url_root()` относительно текущего `ROUTE_ROOT`; ядро формирует сразу готовые абсолютные URL относительно `request.root`, с учётом `COMS_PATH`;
- при обнаружении CSS/JS-файла URL добавляется в один из стеков `hdl.preload.css` или `hdl.preload.js`;
- для обычных обработчиков значения добавляются в конец стека через `sys_opt_push_unique()`, что защищает от повторного подключения одной и той же статики.

Таким образом, `hdl.preload.<css|js>` — это последовательность URL-ов, которую ядро заполняет по мере маршрутизации и обработки зависимостей; дальнейшая логика вывода полностью лежит на шаблоне.

### initial sub-stack и флаг HDL_INIT

Флаг `HDL_INIT` включается совместно с флагами статики (например, `HDL_TPL_CSS_JS | HDL_INIT`) и управляет положением файлов в стеке. Он вводит понятие *initial sub-stack* — начального подстека для статики с повышенным приоритетом загрузки.

Поведение следующее:

- для первого обработчика с флагом `HDL_INIT` его CSS/JS вставляются в позицию `0` соответствующего стека (`hdl.preload.css` или `hdl.preload.js`);
- для каждого следующего обработчика с `HDL_INIT` его статика вставляется сразу *после* уже добавленных «инициализирующих» файлов (внутренние счётчики `$_H_PRELOAD_CSS_INIT_POS` и `$_H_PRELOAD_JS_INIT_POS` отслеживают длину этого подстека);
- обработчики без `HDL_INIT` по-прежнему добавляют свои файлы в хвост стека через `sys_opt_push_unique()`.

В результате каждый стек логически делится на две зоны:

- *initial sub-stack* — начальный отрезок, сформированный обработчиками с `HDL_INIT` в порядке их обнаружения;
- "обычный" хвост — статика всех остальных обработчиков.

Практический эффект: любое количество базовых layout-ов, инфраструктурных компонентов и общесистемных виджетов может гарантированно поставить свои стили/скрипты в голову стека, независимо от глубины вложенности и порядка вызовов обработчиков.

### Вывод статики в шаблоне

Ядро только собирает URL-ы; рендеринг тегов `<link>` и `<script>` целиком остаётся на стороне шаблонов и/или компонента разметки. Для чтения стеков можно использовать `sys_opt_values()`:

Один блок ставится в шапке шаблона, в `<head>...</head>` секцию:

```php
<!-- Styles -->
<?php foreach (sys_opt_values('hdl.preload.css') as $css): ?>
    <link href="<?=$css?>?v=<?=TIME_HASH?>" rel="stylesheet" type="text/css">
<?php endforeach; ?>

<!-- Scripts -->
<?php foreach (sys_opt_values('hdl.preload.js') as $js): ?>
    <script src="<?=$js?>?v=<?=TIME_HASH?>"></script>
<?php endforeach; ?>
```

TIME_HASH определяется в глобальной конфигурации как time-based hash и традиционно используется как GET-параметр для принудительной перезагрузки статики в браузере. Здесь он органично дополняет механизм `hdl.preload.*`: любые изменения статики начинают подхватываться без ручной очистки кэша.

Флаг `HDL_INIT` следует использовать исключительно для добавления глобальных стилей и скриптов, глобальных CSS-фреймворков и JS-библиотек, всё остальное собирается в массивы предзагрузки автоматически, в порядке логики нахождения обработчиков (от общего к частному).


Вспомогательные функции маршрутизатора
--------------------------------------

Эти функции не участвуют в маршрутизации напрямую, но позволяют формировать "правильные" ссылки на обработчики и статические ресурсы, опираясь на те же правила и конфигурацию, что использует ядро.

`core_route_path_to_url($handler_path)` - строит внешний URL по маршруту обработчика. Использует ту же нормализацию, что и `core_use_handler()`: строка вида 'demo.core' превращается в путь '/demo/core', который далее обрабатывается `.htaccess` и роутером.

`core_static_url_path($tpl_path = __DIR__)` - возвращает относительный URL-путь к папке `/web` для указанного обработчика/шаблона (без протокола и хоста). Обычно вызывается из `tpl.*.php` с параметром `__DIR__`.

`core_static_url_root($tpl_path = __DIR__)` - делает то же самое, но сразу добавляет протокол и хост на основе `request.root`

`core_static_url($tpl_path = __DIR__)` - алиас к `core_static_url_path()`.


Отладка и VIP режим
-------------------

В ядре присутствует две библиотеки упрощающих разработку и отладку:

- `/libs/inc.dump.php` - вывод отладочной информации;
- `/libs/inc.helpers.php` - вспомогательные URL-команды.

### inc.dump.php

Определяет три важных функции:

- `dump(...$values)` - форматированный вывод переданных значений;
- `ndump($name, $value)` - вывод значения с именем переменной;
- `tdump(...$values)` - табличный вывод массива в виде "ключ-значение".

И еще одна полезная обёртка, которая выводит dump() в JS консоль:

`dump_js_log(...$values)`

Это может быть нужно для отладки на продакшне, когда сайт уже жив и нужно вывести отладочную информацию не сломав отображение сайта.

### inc.helpers.php

Этот файл содержит множество URL-команд вида ?dump-sys, которые выводят форматированный дамп соответствующих данных. Файл имеет небольшой объем и простую структуру, для ознакомления с полным перечнем команд рекомендуется ознакомиться с исходным кодом библиотеки.

Эти библиотеки подключаются ядром только в VIP режиме. Как его активировать описано в разделе "Инициализация системы", части про глобальную конфигурацию.


Продвинутые функции
-------------------

`set_route_root($new_root = null, $auto_store = true)`, `restore_route_root()` — позволяют временно изменить корень маршрутизации и затем вернуть исходное значение. Эта возможность добавлена для тестирования маршрутизатора на тестовом дереве. Но, вероятно, может найти и другое практическое применение (для организации параллельной архитектуры проекта, a/b тестирования и т.п.).

**ВАЖНО:** при переключении дерева компонентов механизм зависимостей так же начинает работать с новым деревом. Функции core_use_api() и core_use_handler() работают исключительно в пределах одного дерева компонентов.

