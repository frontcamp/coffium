
Производительность
==================

Этот документ содержит рекомендации по повышению скорости работы проектов на базе фреймворка Coffium в стандартной комплектации.

Архитектура Coffium — процедурная, с линейной файлово-ориентированной маршрутизацией: запрос сразу направляется к конкретному обработчику без дополнительных слоёв масок, условий и регулярных выражений. Ядро уже спроектировано как болид Формулы-1: минимум обвязки вокруг обработчиков при сохранении базового удобства компонентной системы. В такой конфигурации фреймворк можно рассматривать как «спорткар»: итоговая производительность определяется тем, насколько аккуратно написаны компоненты и прикладной код.


Область применения документа
----------------------------

Рекомендации ниже полезны:

- при первичной настройке проекта;
- при аудитах производительности и профилировании;
- при проектировании новых компонентов (`/coms/*`);
- при подготовке к выкатке на прод-окружение (`IS_PROD`).

Список не претендует на полноту и будет дополняться по мере развития ядра и появления новых компонентов.


Чеклист производительности
--------------------------

Список пунктов, которые стоит проверить перед нагрузочными тестами или выкладкой на прод. Подробно эти же темы раскрыты в следующих разделах.

- [ ] корректно определяются окружения `IS_LOCAL/IS_DEV/IS_PROD`;
- [ ] на `IS_PROD` отключён вывод ошибок в браузер, включено логирование в файл;
- [ ] вспомогательные отладочные инструменты и VIP-доступ не используются в боевом трафике;
- [ ] тяжелая бизнес-логика вынесена в отдельные компоненты, фоновые задания или CRON;
- [ ] статические ресурсы обслуживаются с учётом кеширования (HTTP/браузер + `TIME_HASH`);
- [ ] на горячих участках минимизировано логирование и внешние вызовы;
- [ ] для работы с БД используются индексы и заранее продуманные запросы;
- [ ] проект регулярно профилируется и ревьюится с учётом реального трафика.


Что уже даёт ядро
-----------------

Из коробки Coffium настроен на высокую скорость:

- минимальный набор подключаемых файлов в точке входа (`index.php`, конфиги и базовые библиотеки в `/libs`);
- процедурный стиль без ООП-надстроек;
- файлово-ориентированная маршрутизация через системный реестр и `core_use_handler()` без дополнительного DSL поверх URL;
- централизованная конфигурация PHP (компрессия, сессии, логирование) в `cfg.global.php`;
- базовые настройки для сжатия вывода (`zlib.output_compression`) и консистентной работы с сессиями;
- собственный обработчик ошибок, позволяющий разделять поведение между DEV и PROD.

Дальнейшая оптимизация — задача прикладного кода и компонентов. Остальные разделы описывают, как не разрушить заложенный задел.


Окружения и конфигурация
------------------------

- Следить за корректной установкой флагов `IS_LOCAL`, `IS_DEV`, `IS_PROD` и `IS_CRON`. От них зависят:
  - уровень логирования;
  - отображение ошибок;
  - поведение сессий;
  - поведение вспомогательных инструментов;
  - безопасность.
- В `cfg.global.php` и `cfg.server.php` не добавлять тяжёлую логику (запросы к БД, HTTP-вызовы, сложные вычисления). Конфиги должны оставаться тонкими.
- Использовать `TIME_HASH` для инвалидации кеша статики осознанно:
  - на DEV можно использовать более частый hash (по секундам, минутам);
  - на PROD — более «длинный» hash (по часам, суткам и реже менять его при релизах).
- Для тяжёлых задач, завязанных на окружение (например, массовые миграции), предусматривать отдельные CRON-сценарии с логикой в компонентах, а не в конфиге.


Ядро, маршрутизация и компоненты
--------------------------------

- Поддерживать идеологию «один обработчик — одна зона ответственности». Лишняя логика в `act.*.php` и `tpl.*.php` ухудшает читаемость и затрудняет оптимизацию.
- Избегать глубоких цепочек вложенных обработчиков (`core_use_handler()` внутри `core_use_handler()`), если это не оправдано. Лучше явно декомпозировать логику на компоненты и виджеты.
- Помнить про принцип максимальной декомпозиции - не превращать обработчики в универсальные «комбайны»:
  - сложную бизнес-логику выносить в отдельные API-функции компонента;
  - шаблоны держать максимально «тонкими» и ограничиваться выводом.
- Не злоупотреблять `CORE_ENABLE_BUFFER` и `CORE_RETURN_OUTPUT` для больших объёмов HTML. Буферизация удобна для виджетов и компоновки, но для потокового вывода больших страниц она может быть лишней и затруднять отладку.
- При проектировании компонентов учитывать, что каждый лишний include и каждая лишняя точка входа в файловую систему добавляют латентность. Не дробить структуру до абсурда.


Логирование и отладка
---------------------

- Логи — это инструмент диагностики, а не трассировка каждого шага:
  - логировать только ошибки, предупреждения и ключевые события;
  - избегать подробного логирования в циклах и на высокочастотных маршрутах.
- Разделять DEV и PROD:
  - на `IS_DEV` можно включать детальное логирование и вывод ошибок;
  - на `IS_PROD` — писать только в лог-файл, исключая вывод деталей в ответ.
- Использовать единый лог-файл в `/logs` для ядра и ключевых компонентов, либо разумное разбиение по типам (например, `error.log`, `slow.log`), но не десятки файлов с логами по мелочам.
- Для измерения времени выполнения отдельных участков — использовать вспомогательные функции из `libs/inc.helpers.php` только в локальной и DEV-среде:
  - не оставлять включённые профайлеры и дамперы в коде, который обрабатывает боевой трафик;
  - оборачивать такие вызовы проверкой окружения (`IS_LOCAL`, `IS_DEV`, `IS_VIP`).


Работа с БД и внешними сервисами
--------------------------------

Хотя ядро Coffium не навязывает конкретный слой доступа к данным, в проектах на базе фреймворка обычно используются компоненты для работы с БД и внешними API.

Рекомендации:

- Проектировать запросы к БД исходя из реальных сценариев:
  - не загружать лишние поля и записи;
  - использовать индексы по фильтрующим и сортирующим полям;
  - избегать N+1-запросов в циклах.
- Операции записи, особенно массовые, по возможности выносить:
  - в отдельные обработчики, вызываемые вручную или CRON’ом;
  - в очередь или промежуточное хранилище (по мере появления соответствующих компонентов).
- Для внешних HTTP/REST-сервисов:
  - учитывать таймауты и ретраи;
  - кешировать результаты, если они многоразовые и не требуют мгновенной консистентности;
  - не блокировать рендеринг страницы длительными внешними вызовами без необходимости.


Файлы, статика и фронтенд
-------------------------

- Чётко разделять код и данные:
  - код компонентов — в `/coms`;
  - временные и кеш-файлы — в `/temp`;
  - динамические данные — в `/data` или в БД;
  - документацию — в `/docs`.
- Для статических ресурсов:
  - использовать `TIME_HASH` в URL (см. раздел конфигурации) и не менять его чаще, чем это оправдано;
  - объединять и минифицировать CSS/JS силами сборки проекта;
  - уделять внимание размерам изображений и формату (WebP и т.п.).
- Не генерировать большие файлы на лету при каждом запросе. Если контент тяжёлый и редко меняется — лучше кэшировать его в файле или БД и обслуживать уже из кеша.
- Для страниц с высокой посещаемостью рассматривать частичное кеширование:
  - статических блоков (меню, футер, повторяющийся контент);
  - агрегированных списков, которые обновляются по расписанию.


Тестирование и профилирование
-----------------------------

- Регулярно запускать юнит- и интеграционные тесты ядра (`/libs/tests`) и компонентов:
  - это косвенно влияет на производительность, уменьшая риск «случайных» регрессий.
- Для анализа производительности использовать:
  - встроенные инструменты PHP и расширения профилирования;
  - точечные замеры времени в критичных местах (в DEV окружении).
- При обнаружении «узких мест»:
  - сначала искать горячие циклы, лишние запросы к БД и внешним сервисам;
  - затем — лишние include, неоправданную буферизацию и логирование.


Дальнейшее развитие документа
-----------------------------

Этот документ описывает базовые принципы. По мере появления специализированных компонентов (кеш, статистика, очереди, отдельные драйверы БД) сюда будут добавляться разделы:

- рекомендации по использованию компонентного кеша;
- шаблоны высокопроизводительных обработчиков;
- типовые архитектурные паттерны для проектов на Coffium;
- примеры конфигурации для высоконагруженных окружений.

Актуальная информация по конкретным компонентам будет приводиться в их документации: `/coms/{component}/_docs/*.md`. В этом документе фиксируются только общие правила и договорённости по производительности для ядра и систем в целом.
