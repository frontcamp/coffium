
Coffium::UnitTests
==================


В этом документе описана тестовая подсистема ядра Coffium (библиотека `/libs/inc.test.php`).

Библиотека тестирования базируется на функции `_assert()`, которая проверяет переданное булево выражение на строгое равенство `true`, при провале записывает сообщение в лог и выводит HTML-сообщение в поток ответа, а при успехе ничего не пишет в лог и (при наличии `GET/POST` параметра verbose) выводит информационное HTML-сообщение. Поверх неё реализован набор хелперов `core_assert_*()` и функция `launch_tests($path)` для автоматического запуска тестов - PHP файлов из указанного каталога и выполнения в них функций с суффиксом `*_test`.


Назначение и общая идея
-----------------------

Цель подсистемы — дать минималистичный, но удобный механизм:

- писать тесты в виде обычных PHP-функций;
- проверять любые условия через компактные `core_assert_*()` вызовы;
- запускать тесты пакетно по каталогу/файлу с автопоиском функций.

Подход минималистичный: без внешних зависимостей, конфигурации и отдельного раннера — только библиотека `/libs/inc.test.php` и вызов `launch_tests()` откуда удобно.


Базовая функция `_assert()`
---------------------------

Сигнатура (внутренняя, не предназначена для прямого использования в тестах):

```php
_assert($value, ...$args);
```

- вычисляется короткий backtrace, чтобы определить:
    - файл теста;
    - строку вызова;
    - имя функции, из которой был вызван ассерт;
- дополнительные аргументы `$args` сериализуются через `var_export()` и используются только для диагностического вывода: в HTML-сообщениях, а при провале — ещё и в записи в лог;
- если `$value === true`:
    - при наличии в `GET/POST` запросе параметра `verbose` на экран выводится HTML-сообщение об успешной проверке с префиксом `Passed:` и указанием функции, аргументов, файла и строки вызова;;
    - в лог ничего не пишется;
- если `$value !== true`:
    - в системный лог (`error_log`) пишется сообщение о провале проверки с именем функции, ее аргументами и указанием файла и строки вызова;
    - в вывод ответа отправляется HTML-сообщение с теми же данными.

Возвращаемые значения:
- `true` — ассерт прошёл;
- `false` — ассерт провален, сообщение уже записано в лог и отправлено в вывод.

Хелперы `core_assert_*()` всегда возвращают булево значение (`true` при успешной проверке и `false` при провале), при этом внутри могут вызывать `_assert()` один или несколько раз.


Мягкое и жёсткое сравнение
--------------------------

Терминология библиотека задаёт прямо в коде:
- **equal** — сравнение с приведением типов (==);
- **same** — строгое сравнение (===).

Это отражено в названиях функций-хелперов:

- `core_assert_equal()` / `core_assert_const_and_equal()` — мягкое сравнение;
- `core_assert_same()` / `core_assert_const_and_same()` — жёсткое сравнение.


Хелперы `core_assert_*()`
-------------------------

Все публичные функции ассерт-хелперов имеют префикс `core_assert_` (т.к. подсистема является частью ядра) и сводятся к вызову `_assert()`. Ниже — краткая сводка по группам.


Проверка "истинности"
---------------------

```php
core_assert($v);        # мягкая истинность ($v == true)
core_assert_true($v);   # строго true ($v === true);
core_assert_false($v);  # строго false ($v === false);
core_assert_empty($v);  # нет или мягко false (empty($v))
core_assert_zero($v);   # строго 0 ($v === 0);
core_assert_null($v);   # строго null (is_null($v));
core_assert_pnull($v);  # строго псевдо-NULL ($v === P_NULL)
```

`P_NULL` определяется в библиотеке системного реестра.


Проверка типов
--------------

Эти функции проверяют тип значения через стандартные `is_*()`:

```php
core_assert_array($a);     # is_array($a)
core_assert_bool($v);      # is_bool($v)
core_assert_int($v);       # is_int($v)
core_assert_float($v);     # is_float($v)
core_assert_numeric($v);   # is_numeric($v)
core_assert_string($v);    # is_string($v)
core_assert_object($v);    # is_object($v)
core_assert_resource($r);  # is_resource($r)
```


Проверка значений и сравнений
-----------------------------

```php
core_assert_equal($a, $b);  # мягкое равенство: $a == $b
core_assert_same($a, $b);   # жёсткое равенство: $a === $b
core_assert_same_arrays($a1, $a2);  # равенство через сравнение хешей
core_assert_gt($a, $b);     # $a > $b
core_assert_gte($a, $b);    # $a >= $b
core_assert_lt($a, $b);     # $a < $b
core_assert_lte($a, $b);    # $a <= $b
```


Константы и ключи
-----------------

```php
core_assert_const($c);                # проверка наличия константы
core_assert_const_and_equal($c, $v);  # проверка наличия и мягкое равенство
core_assert_const_and_same($c, $v);   # проверка наличия и жесткое равенство
core_assert_key_exists($k, $a);         # проверка наличия ключа $a[$k]
```


Файловая система
----------------

```php
core_assert_file($p);  # проверка, что путь указывает на файл
core_assert_dir($p);   # проверка, что путь указывает на каталог
```


Глобальный запуск тестов: `launch_tests($path)`
===============================================

Поддерживаются два режима:

1) `$path` — каталог

    - путь нормализуется (`rtrim` слэшей);
    - символические ссылки игнорируются;
    - выполняется рекурсивный обход каталога;
    - для каждого элемента вызывается `launch_tests()` (рекурсия);

2) `$path` — файл

    - не-PHP файлы игнорируются;
    - несуществующие пути игнорируются (если путь не указывает ни на каталог, ни на файл, тесты не запускаются);
    - перед подключением фиксируется список пользовательских функций:

```
$funcs = get_defined_functions()['user'];
require($path);
$tests = array_values(array_diff(get_defined_functions()['user'], $funcs));
```

    - для всех новых пользовательских функций выбираются только те, которые:

        - не начинаются с символа '_' (приватные/служебные функции игнорируются);
        - оканчиваются на суффикс '_test';
        - каждая такая функция вызывается без аргументов.

Независимо от режима, модуль выводит имена тестовых модулей (PHP файлов). При наличии параметра `verbose` в `GET/POST` запросе перед запуском каждой функции `*_test` выводится:

`Function: <name>()`


Протокол именования тестов
--------------------------

Для корректной работы launch_tests() нужно соблюдать простые правила:

- тестовые функции должны быть глобальными (не методами класса);
- имя тестовой функции:
    - не должно начинаться с '_';
    - должно заканчиваться на '_test';
    - все вспомогательные функции в тестовых файлах рекомендуется:
        - либо называть с префиксом '_', чтобы их не подхватил раннер;
        - либо выносить в отдельные файлы и подключать до вызова launch_tests().

Пример:

```php
<?php

function _prepare_fixture()
{
    // служебный код
}

function registry_basic_test()
{
    _prepare_fixture();
    core_assert_const('P_NULL');
    core_assert_pnull(P_NULL);
}
```


Интеграция с URL-хелперами
--------------------------

В библиотеке `/libs/inc.helpers.php` есть удобный шлюз для запуска тестов ядра:

```php
if (isset($_REQUEST['core-test']))
{
    require_once('inc.test.php');
    launch_tests(PROJ_ROOT.'/libs/tests/');
}
```

По умолчанию он запускает все тесты в каталоге: `/libs/tests/`.

Таким образом, при активном VIP режиме:

- запрос `?core-test` запустит все тесты, выводя названия тестовых модулей (PHP файлов) и ошибки;
- запрос `?core-test&verbose=1` дополнительно покажет имена тестовых функций и успешные ассерты.


Рекомендации по организации тестов
----------------------------------

- Хранить тесты ядра и его библиотек в `/libs/tests/`.
- Для компонентов использовать однотипную структуру, например:
    - `/coms/<component>/_tests/*.php`
    - и отдельный «агрегатор» для их запуска через `launch_tests()`.
- Не смешивать production-код и тесты в одних и тех же файлах.

